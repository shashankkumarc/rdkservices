/**
* If not stated otherwise in this file or this component's LICENSE
* file the following copyright and licenses apply:
*
* Copyright 2019 RDK Management
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
**/

/**
 * @file ramTestClient.cpp
 * @brief Thunder Plugin based Implementation of CPP Test Client for RemoteActionMapping service API's.
 * @reference RDK-25853.
 */

#include <iostream>
#include <bits/stdc++.h>
#include <string>

#include "Module.h"

#include <sys/ioctl.h>
#include <stdio.h>
#include <unistd.h>

#include <vector>

#define SYSSRV_CALLSIGN "org.rdk.RemoteActionMapping.1"
#define SERVER_DETAILS  "127.0.0.1:9998"

using namespace std;
using namespace WPEFramework;

typedef std::vector<int>  int_vector_t;

#define MAX_MSO_RF_CODES    (7)
// Global data used to for arguments to pass to the plugin methods
int deviceID = 1;
int keymapType = 0;         // 0 == IRDB, 1 == All Keys

int currentTVFiveDigitCode = 0;
int currentAVRFiveDigitCode = 0;

const int_vector_t* currentTVIRData = NULL;
const int_vector_t* currentAVRIRData = NULL;

const std::vector<std::string> tvDevices = { "No TV", "Samsung", "Magnavox", "LG", "Samsung w/NoToggle", "Samsung w/NoDiscrete" };
const std::vector<std::string> avrDevices = { "No AVR", "Sony", "Onkyo", "Yamaha", "Sony w/NoToggle" , "Sony w/NoDiscrete" };

int currentTVidx = 0;
string currentTV = tvDevices[0];
int currentAVRidx = 0;
string currentAVR = avrDevices[0];

//POWER_TOGGLE, POWER_OFF, POWER_ON, VOL+, VOL-, MUTE, INPUT/SELECT
const int RFKeyCodes[MAX_MSO_RF_CODES] = {0x6B, 0x6C, 0x6D, 0x41, 0x42, 0x43, 0x34};
//KED_POWER, KED_DSCRT_PWR_STANDBY, KED_DSCRT_PWR_ON, KED_VOLUMEUP, KED_VOLUMEDOWN, KED_MUTE, KED_INPUTKEY
const int KEDKeyNames[MAX_MSO_RF_CODES] = {0x80, 0x51, 0x50, 0x8A, 0x8B, 0x8C, 0xD0};

// Samsung TVs (LN46C610N1F, UN22F5000AF, UN46B8000XF, P2370HD
const int_vector_t samsungTVIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x13, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x22, 0x20},
    {0x04, 0x13, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x33, 0x22, 0x33, 0x22, 0x22, 0x33, 0x22, 0x30},
    {0x04, 0x13, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x33, 0x22, 0x33, 0x23, 0x22, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x23, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x22, 0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x22, 0x20}
};

// Sony AVRs (STR-DH500, STR-DH740)
const int_vector_t sonyAVRIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x18, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xEC, 0x13, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x12, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x12, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x82, 0x14, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x13, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x13, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xAE, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x18, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xAE, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x00}
};

// Magnavox TV (24ME403V/F7)
const int_vector_t magnavoxTVIRData[MAX_MSO_RF_CODES] =
{
    {0x0E, 0x11, 0x03, 0x00, 0x1D, 0x00, 0xDE, 0x00, 0x00, 0x00, 0xAF, 0x57, 0x00, 0x00, 0xDE, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x12, 0x12, 0x21, 0x21, 0x00, 0x04, 0x02, 0x21, 0x12, 0x21},
    {0x00},
    {0x00},
    {0x0E, 0x11, 0x03, 0x00, 0x1D, 0x00, 0xDE, 0x00, 0x00, 0x00, 0xAF, 0x57, 0x00, 0x00, 0xDE, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x12, 0x21, 0x21, 0x21, 0x21, 0x00, 0x04, 0x02, 0x21, 0x12, 0x21},
    {0x0E, 0x11, 0x03, 0x00, 0x1D, 0x00, 0xDE, 0x00, 0x00, 0x00, 0xAF, 0x57, 0x00, 0x00, 0xDE, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x12, 0x21, 0x21, 0x21, 0x12, 0x00, 0x04, 0x02, 0x21, 0x12, 0x21},
    {0x0E, 0x11, 0x03, 0x00, 0x1D, 0x00, 0xDE, 0x00, 0x00, 0x00, 0xAF, 0x57, 0x00, 0x00, 0xDE, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x12, 0x12, 0x21, 0x12, 0x00, 0x04, 0x02, 0x21, 0x12, 0x21},
    {0x0E, 0x11, 0x03, 0x00, 0x1D, 0x00, 0xDE, 0x00, 0x00, 0x00, 0xAF, 0x57, 0x00, 0x00, 0xDE, 0x00, 0xDE, 0x00, 0x00, 0x00, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x21, 0x21, 0x12, 0x12, 0x12, 0x21, 0x21, 0x21, 0x00, 0x04, 0x02, 0x21, 0x12, 0x21}
};

// Onkyo AVR (HT-R380)
const int_vector_t onkyoAVRIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x11, 0x06, 0x26, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x54, 0x54, 0x45, 0x54, 0x45, 0x44, 0x54, 0x44, 0x55, 0x54, 0x55, 0x55, 0x44, 0x45, 0x41, 0x30, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x26, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xE3, 0x25, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x54, 0x54, 0x44, 0x54, 0x45, 0x44, 0x55, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x41, 0x30, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x26, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x54, 0x54, 0x45, 0x54, 0x45, 0x44, 0x54, 0x44, 0x55, 0x54, 0x55, 0x55, 0x44, 0x45, 0x41, 0x30, 0x30, 0x30},
    {0x04, 0x11, 0x04, 0x44, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xE3, 0x25, 0xCA, 0x08, 0x65, 0x04, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x13, 0x23, 0x32, 0x32, 0x22, 0x32, 0x23, 0x22, 0x33, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x22, 0x20, 0x13, 0x23, 0x32, 0x32, 0x22, 0x32, 0x23, 0x22, 0x33, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x22, 0x20, 0x13, 0x23, 0x32, 0x32, 0x22, 0x32, 0x23, 0x22, 0x33, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x44, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xE3, 0x25, 0xCA, 0x08, 0x65, 0x04, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x13, 0x23, 0x32, 0x32, 0x22, 0x32, 0x23, 0x22, 0x32, 0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x22, 0x20, 0x13, 0x23, 0x32, 0x32, 0x22, 0x32, 0x23, 0x22, 0x32, 0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x22, 0x20, 0x13, 0x23, 0x32, 0x32, 0x22, 0x32, 0x23, 0x22, 0x32, 0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x22, 0x20},
    {0x04, 0x11, 0x06, 0x26, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xE3, 0x25, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x54, 0x54, 0x44, 0x54, 0x45, 0x44, 0x54, 0x54, 0x55, 0x55, 0x55, 0x45, 0x44, 0x44, 0x41, 0x30, 0x30, 0x30},
    {0x00}
};

// Yamaha AVR (RX-V373)
const int_vector_t yamahaAVRIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x11, 0x06, 0x24, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x44, 0x44, 0x44, 0x54, 0x55, 0x55, 0x55, 0x45, 0x45, 0x45, 0x45, 0x54, 0x54, 0x54, 0x54, 0x41, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x24, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x44, 0x44, 0x44, 0x54, 0x55, 0x55, 0x55, 0x45, 0x44, 0x44, 0x44, 0x54, 0x55, 0x55, 0x55, 0x41, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x24, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x44, 0x44, 0x44, 0x54, 0x55, 0x55, 0x55, 0x44, 0x44, 0x44, 0x44, 0x55, 0x55, 0x55, 0x55, 0x41, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x24, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x44, 0x44, 0x54, 0x54, 0x55, 0x55, 0x45, 0x45, 0x44, 0x55, 0x54, 0x54, 0x55, 0x44, 0x41, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x24, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x44, 0x44, 0x54, 0x54, 0x55, 0x55, 0x44, 0x45, 0x44, 0x55, 0x55, 0x54, 0x55, 0x44, 0x41, 0x30, 0x30},
    {0x04, 0x11, 0x06, 0x24, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0xFC, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA2, 0x01, 0x90, 0x00, 0x89, 0x00, 0x25, 0x45, 0x44, 0x44, 0x54, 0x54, 0x55, 0x55, 0x45, 0x54, 0x44, 0x55, 0x54, 0x45, 0x55, 0x44, 0x41, 0x30, 0x30},
    {0x00}
};

// Samsung TVs (LN46C610N1F, UN22F5000AF, UN46B8000XF, P2370HD, but missing toggle power IR code
const int_vector_t samsungNoTogTVIRData[MAX_MSO_RF_CODES] =
{
    {0x00},
    {0x04, 0x13, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x33, 0x22, 0x33, 0x22, 0x22, 0x33, 0x22, 0x30},
    {0x04, 0x13, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x33, 0x22, 0x33, 0x23, 0x22, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x23, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x22, 0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x22, 0x20}
};

// Samsung TVs (LN46C610N1F, UN22F5000AF, UN46B8000XF, P2370HD, but missing discrete power on and off IR codes
const int_vector_t samsungNoDisTVIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x13, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x22, 0x20},
    {0x00},
    {0x00},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x23, 0x23, 0x33, 0x33, 0x32, 0x32, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x22, 0x23, 0x33, 0x33, 0x33, 0x32, 0x22, 0x20},
    {0x04, 0x11, 0x04, 0x00, 0x22, 0x00, 0xD2, 0x00, 0x90, 0x00, 0x04, 0x2D, 0x65, 0x04, 0x65, 0x04, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x12, 0x22, 0x33, 0x33, 0x32, 0x22, 0x33, 0x33, 0x32, 0x33, 0x33, 0x33, 0x33, 0x22, 0x22, 0x22, 0x20}
};

// Sony AVRs (STR-DH500, STR-DH740)
const int_vector_t sonyNoTogAVRIRData[MAX_MSO_RF_CODES] =
{
    {0x00},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xEC, 0x13, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x12, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x12, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x82, 0x14, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x13, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30, 0x13, 0x22, 0x23, 0x23, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xAE, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x18, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xAE, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x00}
};

// Sony AVRs (STR-DH500, STR-DH740)
const int_vector_t sonyNoDisAVRIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x18, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x00},
    {0x00},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xAE, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0x18, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x12, 0x23, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x04, 0x11, 0x04, 0x20, 0x10, 0x00, 0xC8, 0x00, 0x96, 0x00, 0xAE, 0x15, 0x58, 0x02, 0x96, 0x00, 0x2C, 0x01, 0x96, 0x00, 0x96, 0x00, 0x96, 0x00, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30, 0x13, 0x32, 0x32, 0x33, 0x33, 0x33, 0x22, 0x30},
    {0x00}
};

// LG TV (India model 22LD310)
const int_vector_t lgTVIRData[MAX_MSO_RF_CODES] =
{
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x45, 0x55, 0x45, 0x55, 0x54, 0x44, 0x54, 0x44, 0x41, 0x30},
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x44, 0x54, 0x55, 0x54, 0x45, 0x45, 0x44, 0x45, 0x51, 0x30},
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x45, 0x54, 0x55, 0x54, 0x44, 0x45, 0x44, 0x45, 0x51, 0x30},
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x45, 0x45, 0x55, 0x55, 0x54, 0x54, 0x44, 0x44, 0x41, 0x30},
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x44, 0x45, 0x55, 0x55, 0x55, 0x54, 0x44, 0x44, 0x41, 0x30},
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x44, 0x55, 0x45, 0x55, 0x55, 0x44, 0x54, 0x44, 0x41, 0x30},
    {0x04, 0x11, 0x06, 0x22, 0x02, 0x00, 0xD2, 0x00, 0x90, 0x00, 0xEB, 0x5D, 0x90, 0x00, 0x6C, 0x26, 0xCA, 0x08, 0x65, 0x04, 0xCA, 0x08, 0x32, 0x02, 0x90, 0x00, 0xA6, 0x01, 0x90, 0x00, 0x8D, 0x00, 0x25, 0x54, 0x55, 0x55, 0x54, 0x45, 0x44, 0x44, 0x44, 0x45, 0x45, 0x55, 0x55, 0x54, 0x54, 0x44, 0x41, 0x30}
};

/* Declare module name */
MODULE_NAME_DECLARATION(BUILD_REFERENCE)

/* This section can be used for API validation logic. */
void showMenu()
{

    std::cout<<"\n\nRemoteActionMapping API Methods:                Current Parameter Settings:\n";
    std::cout<<"0.getQuirks()                                   a.Cycle thru 'deviceID' values [1 thru 9]: " << deviceID << "\n";
    std::cout<<"1.getApiVersionNumber()                         b.Toggle 'keymapType' [IRDB Keys(0) | All Keys(1)]: " << keymapType << "\n";
    std::cout<<"2.getLastUsedDeviceID()                         c.Cycle thru available TV devices: " << currentTV << "\n";
    std::cout<<"3.getKeymap()                                   d.Cycle thru available AVR devices: " << currentAVR << "\n";
    std::cout<<"4.setKeyActionMapping()                         e.Enter the 'tvFiveDigitCode' value: " << currentTVFiveDigitCode << "\n";
    std::cout<<"5.setFiveDigitCode()                            f.Enter the 'avrFiveDigitCode' value: " << currentAVRFiveDigitCode << "\n";
    std::cout<<"6.clearKeyActionMapping() (all keys cleared)\n";
    std::cout<<"7.getFullKeyActionMapping()\n";
    std::cout<<"8.getSingleKeyActionMapping() (MUTE key)\n";
    std::cout<<"9.cancelCodeDownload()\n";
    std::cout<<"\nEnter your choice: ";
}

// Modified from normal, for display of key map arrays
void formatForDisplay(std::string& str)
{
    const int indent = 4;
    int level = 0;
    bool bInArray = false;

    for (size_t i = 0; i < str.size(); i++)
    {
        if (!bInArray && (str[i] == ','))
        {
            str.insert((i+1), 1, '\n'); // insert after
            if (level > 0)
            {
                str.insert((i+2), (level * indent), ' ');
            }
        }
        else if (str[i] == '}')
        {
            level--;
            if (level < 0) level = 0;
            str.insert((i), 1, '\n');   // insert before
            if (level > 0)
            {
                // after the newline, but before the curly brace
                str.insert((i+1), (level * indent), ' ');
            }
            i += (level * indent) + 1;    // put i back on the curly brace
        }
        else if (str[i] == '{')
        {
            bInArray = false;
            level++;
            str.insert((i+1), 1, '\n'); // insert after
            if (level > 0)
            {
                str.insert((i+2), (level * indent), ' ');
            }
        }
        else if (str[i] == '[')
        {
            bInArray = true;
        }
        else if (str[i] == ']')
        {
            bInArray = false;
        }
    }
}

// Event parameters sent to JSONRPC::Client event handlers, have somehow
// acquired overall quotation marks, with internal quotes backslash-escaped.
// This function tries to detect and correct that, for console output.
// Should have no effect if the in/out string isn't inside double-quotes.
void removeJsonQuotes(std::string& str)
{
    if ((str.front() == '"') && (str.back() == '"'))
    {
        str.erase(0, 1);
        str.pop_back();

        for (size_t i = 0; i < str.size(); i++)
        {
            if ((i < (str.size() - 1)) && (str[i] == 0x5c) && (str[i+1] == '"'))
            {
                str.erase(i, 1);
            }
        }
    }
}

/***
 * @brief  : compare two C string case insensitively
 * @param1[in] : c string 1
 * @param2[in] : c string 2
 * @return : <bool>; 0 if strings are same, some number if strings are different
 */
int strcicmp(char const *a, char const *b)
{
    int d = -1;
    for (;; a++, b++) {
        d = tolower((unsigned char)*a) - tolower((unsigned char)*b);
        if (d != 0 || !*a) {
            return d;
        }
    }
    return -1;
}

void setCurrentTVData() {
    switch(currentTVidx){
        case 1:
        {
            currentTVIRData = samsungTVIRData;
            break;
        }
        case 2: {
            currentTVIRData = magnavoxTVIRData;
            break;
        }
        case 3:
        {
            currentTVIRData = lgTVIRData;
            break;
        }
        case 4:
        {
            currentTVIRData = samsungNoTogTVIRData;
            break;
        }
        case 5:
        {
            currentTVIRData = samsungNoDisTVIRData;
            break;
        }
        default:
        {
            currentTVIRData = NULL;
        }
    }
}

void setCurrentAVRData() {
    switch(currentAVRidx){
        case 1: {
            currentAVRIRData = sonyAVRIRData;
            break;
        }
        case 2: {
            currentAVRIRData = onkyoAVRIRData;
            break;
        }
        case 3: {
            currentAVRIRData = yamahaAVRIRData;
            break;
        }
        case 4: {
            currentAVRIRData = sonyNoTogAVRIRData;
            break;
        }
        case 5: {
            currentAVRIRData = sonyNoDisAVRIRData;
            break;
        }
        default: {
            currentAVRIRData = NULL;
        }
    }
}

// Make changes in parameters
void handleParams(string& cmd)
{
    switch(cmd[0])
    {
        case 'a':
        {
            // device ID
            if (deviceID < 9)
            {
                deviceID++;
            }
            else
            {
                deviceID = 1;
            }
        }
        break;

        case 'b':
        {
            // keymapType
            if (keymapType == 0)
            {
                keymapType = 1;
            }
            else
            {
                keymapType = 0;
            }
        }
        break;

        case 'c':
        {
            // Cycle thru TV devices
            if (currentTVidx < ((int)tvDevices.size() - 1)) {
                currentTVidx++;
            } else {
                currentTVidx = 0;
            }
            currentTV = tvDevices[currentTVidx];
            setCurrentTVData();
        }
        break;

        case 'd':
        {
            // Cycle thru AVR devices
            if (currentAVRidx < ((int)avrDevices.size() - 1)) {
                currentAVRidx++;
            } else {
                currentAVRidx = 0;
            }
            currentAVR = avrDevices[currentAVRidx];
            setCurrentAVRData();
        }
        break;

        case 'e':
        {
            // Enter TV 5-digit-code
            string digits;
            int number = 0;
            while (digits.empty())
            {
                std::cout << "Enter the TV 5-digit-code (must be 5 numeric digits):";
                std::getline(std::cin, digits);
            }
            number = stoi(digits);
            if (number <= 0)
            {
                std::cout << "Zeroing TV 5-digit-code!";
                currentTVFiveDigitCode = 0;
            }
            else if ((number < 9999) || (number > 99999))
            {
                std::cout << "TV 5-digit-code " << digits << " out of range!  No change!";
            }
            else
            {
                currentTVFiveDigitCode = number;
            }
        }
        break;

        case 'f':
        {
            // Enter AVR 5-digit-codes
            string digits;
            int number = 0;
            while (digits.empty())
            {
                std::cout << "Enter the AVR 5-digit-code (must be 5 numeric digits):";
                std::getline(std::cin, digits);
            }
            number = stoi(digits);
            if (number <= 0)
            {
                std::cout << "Zeroing AVR 5-digit-code!";
                currentAVRFiveDigitCode = 0;
            }
            else if ((number < 9999) || (number > 99999))
            {
                std::cout << "AVR 5-digit-code " << digits << " out of range!  No change!";
            }
            else
            {
                currentAVRFiveDigitCode = number;
            }
        }
        break;
    }
}

/* This section is related to the event handler implementation for RemoteActionMapping Plugin Events. */

namespace Handlers {
    /* Event Handlers */
    static void onIRCodeLoad(const Core::JSON::String& parameters) {
        std::string message;
        parameters.ToString(message);
        removeJsonQuotes(message);
        std::cout << "\n[RAMEvent] " << __FUNCTION__ << ": " << message << std::endl;
    }
    static void onFiveDigitCodeLoad(const Core::JSON::String& parameters) {
        std::string message;
        parameters.ToString(message);
        removeJsonQuotes(message);
        std::cout << "\n[RAMEvent] " << __FUNCTION__ << ": " << message << std::endl;
    }
}

int main(int argc, char** argv)
{
    JSONRPC::LinkType<Core::JSON::IElement>* remoteObject = NULL;

    int choice;
    uint32_t ret;
    string json;
    string cmd;


    Core::SystemInfo::SetEnvironment(_T("THUNDER_ACCESS"), (_T(SERVER_DETAILS)));

    // Security Token
    std::cout << "Retrieving security token" << std::endl;
    std::string sToken;

    FILE *pSecurity = popen("/usr/bin/WPEFrameworkSecurityUtility", "r");
    if(pSecurity) {
        JsonObject pSecurityJson;
        std::string pSecurityOutput;
        size_t pSecurityOutputTrimIndex;
        std::array<char, 256> pSecurityBuffer;

        while(fgets(pSecurityBuffer.data(), 256, pSecurity) != NULL) {
            pSecurityOutput += pSecurityBuffer.data();
        }
        pclose(pSecurity);

        pSecurityOutputTrimIndex = pSecurityOutput.find('{');
        if(pSecurityOutputTrimIndex == std::string::npos) {
            std::cout << "Security Utility returned unexpected output" << std::endl;
        } else {
            if(pSecurityOutputTrimIndex > 0) {
                 std::cout << "Trimming output from Security Utility" << std::endl;
                 pSecurityOutput = pSecurityOutput.substr(pSecurityOutputTrimIndex);
            }
            pSecurityJson.FromString(pSecurityOutput);
            if(pSecurityJson["success"].Boolean() == true) {
                std::cout << "Security Token retrieved successfully!" << std::endl;
                sToken = "token=" + pSecurityJson["token"].String();
            } else {
                std::cout << "Security Token retrieval failed!" << std::endl;
            }
        }
    } else {
        std::cout << "Failed to open security utility" << std::endl;
    }
    // End Security Token

    std::cout << "Using callsign: " << SYSSRV_CALLSIGN << std::endl;

    if (NULL == remoteObject) {
        remoteObject = new JSONRPC::Client(_T(SYSSRV_CALLSIGN), _T(""), false, sToken);
        if (NULL == remoteObject) {
            std::cout << "JSONRPC::Client initialization failed" << std::endl;

        } else {

            {
                // Create a controller client
                static auto& controllerClient = *new WPEFramework::JSONRPC::LinkType<WPEFramework::Core::JSON::IElement>("", "", false, sToken);
                // In case the plugin isn't activated already, try to start it, BEFORE registering for the events!
                string strres;
                JsonObject params;
                params["callsign"] = SYSSRV_CALLSIGN;
                JsonObject result;
                ret = controllerClient.Invoke(2000, "activate", params, result);
                result.ToString(strres);
                std::cout<<"\nstartup result : "<< strres <<"\n";
            }

            /* Register handlers for Event reception. */
            std::cout << "\nSubscribing to event handlers\n" << std::endl;
            if (remoteObject->Subscribe<Core::JSON::String>(1000, _T("onIRCodeLoad"),
                        &Handlers::onIRCodeLoad) == Core::ERROR_NONE) {
                std::cout << "Subscribed to : onIRCodeLoad" << std::endl;
            } else {
                std::cout << "Failed to Subscribe notification handler : onIRCodeLoad" << std::endl;
            }
            if (remoteObject->Subscribe<Core::JSON::String>(1000, _T("onFiveDigitCodeLoad"),
                        &Handlers::onFiveDigitCodeLoad) == Core::ERROR_NONE) {
                std::cout << "Subscribed to : onFiveDigitCodeLoad" << std::endl;
            } else {
                std::cout << "Failed to Subscribe notification handler : onFiveDigitCodeLoad" << std::endl;
            }

            /* API Validation Logic. */
            while (true) {
                json.clear();
                cmd.clear();
                while (cmd.empty())
                {
                    showMenu();
                    std::getline(std::cin, cmd);
                }
                if ((cmd[0] >= '0') && (cmd[0] <= '9'))
                {
                    choice = stoi(cmd);
                }
                else if ((cmd[0] >= 'a') && (cmd[0] <= 'f'))
                {
                    handleParams(cmd);
                    continue;
                }
                else return 0;

                {
                    JsonObject result;  // The Clear method can leave crud.  A new instance off the stack works better.

                    switch (choice) {
                        case 0:
                            {
                                JsonObject params;
                                string res;
                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("getQuirks"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping getQuirks call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping getQuirks call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 1:
                            {
                                JsonObject params;
                                string res;
                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("getApiVersionNumber"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping getApiVersionNumber call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping getApiVersionNumber call - failed!! \n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 2:
                            {
                                JsonObject params;
                                string res;
                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("getLastUsedDeviceID"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping getLastUsedDeviceID call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping getLastUsedDeviceID call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 3:
                            {
                                JsonObject params;
                                string res;
                                params["deviceID"] = JsonValue(deviceID);
                                params["keymapType"] = JsonValue(keymapType);

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("getKeymap"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping getKeymap call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping getKeymap call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 4:
                            {
                                JsonObject params;
                                JsonArray array;
                                string res;
                                // Construct the complex parameters
                                params["deviceID"] = JsonValue(deviceID);
                                params["keymapType"] = JsonValue(keymapType);
                                for (int i = 0; i < MAX_MSO_RF_CODES; i++)
                                {
                                    JsonObject keyMap;
                                    JsonArray tvIRKeyCode;
                                    JsonArray avrIRKeyCode;
                                    bool hasTVCode = false;
                                    bool hasAVRCode = false;

                                    keyMap["keyName"] = JsonValue(KEDKeyNames[i]);
                                    keyMap["rfKeyCode"] = JsonValue(RFKeyCodes[i]);

                                    if ((currentTVIRData != NULL) && (currentTVIRData[i].size() > 1))
                                    {
                                        for (int j = 0; j < (int)currentTVIRData[i].size(); j++)
                                        {
                                            tvIRKeyCode.Add(JsonValue(currentTVIRData[i][j]));
                                        }
                                        hasTVCode = true;
                                    }
                                    keyMap["tvIRKeyCode"] = tvIRKeyCode;

                                    if ((currentAVRIRData != NULL) && (currentAVRIRData[i].size() > 1))
                                    {
                                        for (int j = 0; j < (int)currentAVRIRData[i].size(); j++)
                                        {
                                            avrIRKeyCode.Add(JsonValue(currentAVRIRData[i][j]));
                                        }
                                        hasAVRCode = true;
                                    }
                                    keyMap["avrIRKeyCode"] = avrIRKeyCode;

                                    if(hasTVCode || hasAVRCode)
                                    {
                                        array.Add(keyMap);
                                    }
                                }
                                params["keyActionMapping"] = array;

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("setKeyActionMapping"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping setKeyActionMapping call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping setKeyActionMapping call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 5:
                            {
                                JsonObject params;
                                string res;
                                params["deviceID"] = JsonValue(deviceID);
                                params["tvFiveDigitCode"] = JsonValue(currentTVFiveDigitCode);
                                params["avrFiveDigitCode"] = JsonValue(currentAVRFiveDigitCode);

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("setFiveDigitCode"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping setFiveDigitCode call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping setFiveDigitCode call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 6:
                            {
                                JsonObject params;
                                string res;
                                JsonArray array;
                                params["deviceID"] = JsonValue(deviceID);
                                params["keymapType"] = JsonValue(keymapType);
                                for (int i = 0; i < MAX_MSO_RF_CODES; i++)
                                {
                                    array.Add(JsonValue(KEDKeyNames[i]));               // Clear mappings for all keys
                                }
                                params["keyNames"] = array;

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("clearKeyActionMapping"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"clearKeyActionMapping setValues: success\n";
                                } else {
                                    std::cout<<"clearKeyActionMapping setValues: failure\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 7:
                            {
                                JsonObject params;
                                string res;
                                params["deviceID"] = JsonValue(deviceID);
                                params["keymapType"] = JsonValue(keymapType);

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("getFullKeyActionMapping"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping getFullKeyActionMapping call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping getFullKeyActionMapping call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 8:
                            {
                                JsonObject params;
                                string res;
                                params["deviceID"] = JsonValue(deviceID);
                                params["keymapType"] = JsonValue(keymapType);
                                params["keyName"] = JsonValue(0x8C);                // Use the MUTE key

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("getSingleKeyActionMapping"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping getSingleKeyActionMapping call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping getSingleKeyActionMapping call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        case 9:
                            {
                                JsonObject params;
                                string res;
                                params["deviceID"] = JsonValue(deviceID);

                                ret = remoteObject->Invoke<JsonObject, JsonObject>(1000,
                                                    _T("cancelCodeDownload"), params, result);
                                std::cout<<"RemoteActionMapping Invoke ret : "<< ret <<"\n";
                                result.ToString(res);
                                formatForDisplay(res);
                                if (result["success"].Boolean()) {
                                    std::cout<<"RemoteActionMapping cancelCodeDownload call - Success!\n";
                                } else {
                                    std::cout<<"RemoteActionMapping cancelCodeDownload call - failed!\n";
                                }
                                std::cout<<"result : "<<res<<"\n";
                            }
                            break;

                        default:
                            std::cout<<"Entry not recognized!\n";
                            break;

                    }
                }

                std::cout<<"\n\nTo continue press ENTER; To quit press any other key --> ";

                if (std::cin.peek() == '\n')
                    std::getline(std::cin, cmd);

                std::getline(std::cin, cmd);
                if (cmd.empty())
                    continue;
                else
                    break;
            }
        }
    }

    return 0;
}
